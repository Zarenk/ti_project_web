{
  "permissions": {
    "allow": [
      "Bash(node scripts/generate-secrets.js:*)",
      "Bash(netstat:*)",
      "Bash(PGPASSWORD=jzYPokr7X29RIST5Y_8USEn1cTi1JJYf \"/c/Program Files/PostgreSQL/17/bin/psql.exe\" -U postgres -h localhost -c \"SELECT version\\(\\);\" -t)",
      "WebFetch(domain:github.com)",
      "Bash(git add:*)",
      "Bash(git commit:*)",
      "Bash(npm update:*)",
      "Bash(npm view:*)",
      "Bash(npx prisma:*)",
      "Bash(npm outdated:*)",
      "Bash(powershell:*)",
      "Bash($timestamp = Get-Date -Format \"yyyyMMdd_HHmmss\")",
      "Bash($backupDir = \"backups\\\\prisma-upgrade-$timestamp\")",
      "Bash(New-Item -ItemType Directory -Path $backupDir -Force)",
      "Bash(Out-Null)",
      "Bash(Copy-Item \"backend\\\\package.json\" \"$backupDir\\\\package.json.bak\")",
      "Bash(Copy-Item \"backend\\\\prisma\\\\schema.prisma\" \"$backupDir\\\\schema.prisma.bak\")",
      "Bash(Copy-Item \"backend\\\\src\\\\prisma\\\\prisma.service.ts\" \"$backupDir\\\\prisma.service.ts.bak\")",
      "Bash(Write-Host \"Backup creado en: $backupDir\")",
      "Bash(git tag:*)",
      "Bash(git checkout:*)",
      "Bash(npm install:*)",
      "Bash(node:*)",
      "Bash(npm:*)",
      "Bash(nvm version:*)",
      "Bash(where:*)",
      "Bash(npx tsc:*)",
      "Bash(dir:*)",
      "Bash(npx jest --passWithNoTests)",
      "Bash(npx jest:*)",
      "Bash(ls:*)",
      "WebFetch(domain:lottiefiles.com)",
      "Bash(npx nest start:*)",
      "Bash(curl:*)",
      "Bash(cd:*)",
      "Bash(taskkill:*)",
      "Bash(findstr:*)",
      "Bash(for comp in switch label tooltip)",
      "Bash(do)",
      "Bash(if [ -f \"fronted/src/components/ui/$comp.tsx\" ])",
      "Bash(then)",
      "Bash(echo:*)",
      "Bash(else)",
      "Bash(fi)",
      "Bash(done)",
      "Bash(\"fronted/src/app/api/accounting/journal-entries/route.ts\" << 'EOF'\nimport { NextRequest, NextResponse } from 'next/server';\n\nconst BACKEND_URL = process.env.NEXT_PUBLIC_BACKEND_URL || 'http://localhost:3001';\n\nexport async function GET\\(req: NextRequest\\) {\n  const { searchParams } = new URL\\(req.url\\);\n  \n  const res = await fetch\\(`${BACKEND_URL}/accounting/journal-entries?${searchParams}`, {\n    headers: {\n      Cookie: req.headers.get\\('cookie'\\) || '',\n    },\n  }\\);\n\n  const data = await res.json\\(\\);\n  return NextResponse.json\\(data, { status: res.status }\\);\n}\n\nexport async function POST\\(req: NextRequest\\) {\n  const body = await req.json\\(\\);\n\n  const res = await fetch\\(`${BACKEND_URL}/accounting/journal-entries`, {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json',\n      Cookie: req.headers.get\\('cookie'\\) || '',\n    },\n    body: JSON.stringify\\(body\\),\n  }\\);\n\n  const data = await res.json\\(\\);\n  return NextResponse.json\\(data, { status: res.status }\\);\n}\nEOF)",
      "Bash(\"fronted/src/app/api/accounting/journal-entries/route.ts\" << 'EOF'\nimport { NextRequest, NextResponse } from 'next/server';\n\nconst BACKEND_URL = process.env.NEXT_PUBLIC_BACKEND_URL || 'http://localhost:3001';\n\nexport async function GET\\(req: NextRequest\\) {\n  const { searchParams } = new URL\\(req.url\\);\n  \n  const res = await fetch\\(\\\\`\\\\${BACKEND_URL}/accounting/journal-entries?\\\\${searchParams}\\\\`, {\n    headers: {\n      Cookie: req.headers.get\\('cookie'\\) || '',\n    },\n  }\\);\n\n  const data = await res.json\\(\\);\n  return NextResponse.json\\(data, { status: res.status }\\);\n}\n\nexport async function POST\\(req: NextRequest\\) {\n  const body = await req.json\\(\\);\n\n  const res = await fetch\\(\\\\`\\\\${BACKEND_URL}/accounting/journal-entries\\\\`, {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json',\n      Cookie: req.headers.get\\('cookie'\\) || '',\n    },\n    body: JSON.stringify\\(body\\),\n  }\\);\n\n  const data = await res.json\\(\\);\n  return NextResponse.json\\(data, { status: res.status }\\);\n}\nEOF)",
      "Bash(\"fronted/src/app/api/accounting/journal-entries/[id]/route.ts\" << 'EOF'\nimport { NextRequest, NextResponse } from 'next/server';\n\nconst BACKEND_URL = process.env.NEXT_PUBLIC_BACKEND_URL || 'http://localhost:3001';\n\nexport async function GET\\(req: NextRequest, { params }: { params: { id: string } }\\) {\n  const res = await fetch\\(\\\\`\\\\${BACKEND_URL}/accounting/journal-entries/\\\\${params.id}\\\\`, {\n    headers: {\n      Cookie: req.headers.get\\('cookie'\\) || '',\n    },\n  }\\);\n\n  const data = await res.json\\(\\);\n  return NextResponse.json\\(data, { status: res.status }\\);\n}\n\nexport async function PUT\\(req: NextRequest, { params }: { params: { id: string } }\\) {\n  const body = await req.json\\(\\);\n\n  const res = await fetch\\(\\\\`\\\\${BACKEND_URL}/accounting/journal-entries/\\\\${params.id}\\\\`, {\n    method: 'PUT',\n    headers: {\n      'Content-Type': 'application/json',\n      Cookie: req.headers.get\\('cookie'\\) || '',\n    },\n    body: JSON.stringify\\(body\\),\n  }\\);\n\n  const data = await res.json\\(\\);\n  return NextResponse.json\\(data, { status: res.status }\\);\n}\n\nexport async function DELETE\\(req: NextRequest, { params }: { params: { id: string } }\\) {\n  const res = await fetch\\(\\\\`\\\\${BACKEND_URL}/accounting/journal-entries/\\\\${params.id}\\\\`, {\n    method: 'DELETE',\n    headers: {\n      Cookie: req.headers.get\\('cookie'\\) || '',\n    },\n  }\\);\n\n  const data = await res.json\\(\\);\n  return NextResponse.json\\(data, { status: res.status }\\);\n}\nEOF)",
      "Bash(\"fronted/src/app/api/accounting/journal-entries/[id]/post/route.ts\" << 'EOF'\nimport { NextRequest, NextResponse } from 'next/server';\n\nconst BACKEND_URL = process.env.NEXT_PUBLIC_BACKEND_URL || 'http://localhost:3001';\n\nexport async function POST\\(req: NextRequest, { params }: { params: { id: string } }\\) {\n  const res = await fetch\\(\\\\`\\\\${BACKEND_URL}/accounting/journal-entries/\\\\${params.id}/post\\\\`, {\n    method: 'POST',\n    headers: {\n      Cookie: req.headers.get\\('cookie'\\) || '',\n    },\n  }\\);\n\n  const data = await res.json\\(\\);\n  return NextResponse.json\\(data, { status: res.status }\\);\n}\nEOF)",
      "Bash(\"fronted/src/app/api/accounting/journal-entries/[id]/void/route.ts\" << 'EOF'\nimport { NextRequest, NextResponse } from 'next/server';\n\nconst BACKEND_URL = process.env.NEXT_PUBLIC_BACKEND_URL || 'http://localhost:3001';\n\nexport async function POST\\(req: NextRequest, { params }: { params: { id: string } }\\) {\n  const res = await fetch\\(\\\\`\\\\${BACKEND_URL}/accounting/journal-entries/\\\\${params.id}/void\\\\`, {\n    method: 'POST',\n    headers: {\n      Cookie: req.headers.get\\('cookie'\\) || '',\n    },\n  }\\);\n\n  const data = await res.json\\(\\);\n  return NextResponse.json\\(data, { status: res.status }\\);\n}\nEOF)",
      "Bash(\"fronted/src/app/api/accounting/export/ple/route.ts\" << 'EOF'\nimport { NextRequest, NextResponse } from 'next/server';\n\nconst BACKEND_URL = process.env.NEXT_PUBLIC_BACKEND_URL || 'http://localhost:3001';\n\nexport async function GET\\(req: NextRequest\\) {\n  const { searchParams } = new URL\\(req.url\\);\n\n  const res = await fetch\\(\\\\`\\\\${BACKEND_URL}/accounting/export/ple?\\\\${searchParams}\\\\`, {\n    headers: {\n      Cookie: req.headers.get\\('cookie'\\) || '',\n    },\n  }\\);\n\n  if \\(!res.ok\\) {\n    const error = await res.text\\(\\);\n    return NextResponse.json\\({ error }, { status: res.status }\\);\n  }\n\n  const blob = await res.blob\\(\\);\n  const contentDisposition = res.headers.get\\('content-disposition'\\);\n\n  return new NextResponse\\(blob, {\n    headers: {\n      'Content-Type': 'text/plain; charset=utf-8',\n      'Content-Disposition': contentDisposition || 'attachment; filename=\"export.txt\"',\n    },\n  }\\);\n}\nEOF)",
      "Bash(\"c:\\\\Users\\\\Usuario\\\\Documents\\\\Proyectos PROGRAMACION\\\\TI_projecto_web\\\\backend\\\\ml\\\\help_embeddings.py\" << 'ENDOFFILE'\n#!/usr/bin/env python\n\"\"\"\nGenera sentence embeddings para el asistente de ayuda de ADSLab.\n\nModos de uso:\n  encode-batch  — Lee un JSON array de textos por stdin, devuelve array de embeddings.\n  encode-query  — Recibe un texto como argumento, devuelve un embedding.\n  server        — Modo servidor persistente \\(lee comandos de stdin, escribe resultados a stdout\\)\n\nModelo: paraphrase-multilingual-MiniLM-L12-v2 \\(384 dims, multilingue\\)\n\"\"\"\n\nimport argparse\nimport json\nimport sys\n\n# Lazy imports para que el script falle rapido si se invoca sin dependencias\n_model = None\n\n\ndef get_model\\(\\):\n    global _model\n    if _model is None:\n        from sentence_transformers import SentenceTransformer\n        _model = SentenceTransformer\\('paraphrase-multilingual-MiniLM-L12-v2'\\)\n    return _model\n\n\ndef encode_batch\\(\\):\n    \"\"\"Lee JSON array de textos por stdin, devuelve JSON array de embeddings.\"\"\"\n    raw = sys.stdin.read\\(\\)\n    if not raw.strip\\(\\):\n        print\\(json.dumps\\([]\\), end=''\\)\n        return\n\n    texts = json.loads\\(raw\\)\n    if not isinstance\\(texts, list\\) or len\\(texts\\) == 0:\n        print\\(json.dumps\\([]\\), end=''\\)\n        return\n\n    model = get_model\\(\\)\n    embeddings = model.encode\\(texts, show_progress_bar=False, normalize_embeddings=True\\)\n    result = [emb.tolist\\(\\) for emb in embeddings]\n    print\\(json.dumps\\(result\\), end=''\\)\n\n\ndef encode_query\\(text: str\\):\n    \"\"\"Codifica un texto individual y devuelve su embedding.\"\"\"\n    text = text.strip\\(\\)\n    if not text:\n        print\\(json.dumps\\([]\\), end=''\\)\n        return\n\n    model = get_model\\(\\)\n    embedding = model.encode\\([text], show_progress_bar=False, normalize_embeddings=True\\)\n    print\\(json.dumps\\(embedding[0].tolist\\(\\)\\), end=''\\)\n\n\ndef server_mode\\(\\):\n    \"\"\"\n    Modo servidor: mantiene el modelo cargado en memoria y procesa comandos desde stdin.\n    \n    Formato de comando \\(una línea JSON por comando\\):\n    {\"id\": \"uuid\", \"command\": \"encode-query\", \"params\": {\"text\": \"...\"}}\n    {\"id\": \"uuid\", \"command\": \"encode-batch\", \"params\": {\"texts\": [...]}}\n    \n    Formato de respuesta \\(una línea JSON por respuesta\\):\n    {\"id\": \"uuid\", \"result\": [...]}\n    {\"id\": \"uuid\", \"error\": \"mensaje de error\"}\n    \"\"\"\n    # Pre-cargar el modelo una sola vez\n    model = get_model\\(\\)\n    \n    # Escribir mensaje de ready para indicar que el servidor está listo\n    print\\(json.dumps\\({\"status\": \"ready\"}\\), flush=True\\)\n    \n    while True:\n        try:\n            line = sys.stdin.readline\\(\\)\n            if not line:\n                # EOF - salir del servidor\n                break\n            \n            line = line.strip\\(\\)\n            if not line:\n                continue\n            \n            request = json.loads\\(line\\)\n            request_id = request.get\\('id', 'unknown'\\)\n            command = request.get\\('command'\\)\n            params = request.get\\('params', {}\\)\n            \n            result = None\n            error = None\n            \n            try:\n                if command == 'encode-query':\n                    text = params.get\\('text', ''\\).strip\\(\\)\n                    if not text:\n                        result = []\n                    else:\n                        embedding = model.encode\\([text], show_progress_bar=False, normalize_embeddings=True\\)\n                        result = embedding[0].tolist\\(\\)\n                \n                elif command == 'encode-batch':\n                    texts = params.get\\('texts', []\\)\n                    if not isinstance\\(texts, list\\) or len\\(texts\\) == 0:\n                        result = []\n                    else:\n                        embeddings = model.encode\\(texts, show_progress_bar=False, normalize_embeddings=True\\)\n                        result = [emb.tolist\\(\\) for emb in embeddings]\n                \n                else:\n                    error = f\"Unknown command: {command}\"\n            \n            except Exception as e:\n                error = str\\(e\\)\n            \n            # Enviar respuesta\n            if error:\n                response = {\"id\": request_id, \"error\": error}\n            else:\n                response = {\"id\": request_id, \"result\": result}\n            \n            print\\(json.dumps\\(response\\), flush=True\\)\n        \n        except json.JSONDecodeError as e:\n            # Error al parsear el comando - enviar respuesta de error\n            error_response = {\"id\": \"unknown\", \"error\": f\"JSON parse error: {str\\(e\\)}\"}\n            print\\(json.dumps\\(error_response\\), flush=True\\)\n        \n        except Exception as e:\n            # Error inesperado - loggear y continuar\n            error_response = {\"id\": \"unknown\", \"error\": f\"Unexpected error: {str\\(e\\)}\"}\n            print\\(json.dumps\\(error_response\\), flush=True\\)\n\n\ndef main\\(\\):\n    parser = argparse.ArgumentParser\\(description='Help embeddings para ADSLab'\\)\n    parser.add_argument\\(\n        'mode',\n        choices=['encode-batch', 'encode-query', 'server'],\n        help='Modo de operacion',\n    \\)\n    parser.add_argument\\(\n        '--text',\n        default='',\n        help='Texto a codificar \\(solo para encode-query\\)',\n    \\)\n    args = parser.parse_args\\(\\)\n\n    if args.mode == 'encode-batch':\n        encode_batch\\(\\)\n    elif args.mode == 'encode-query':\n        if not args.text:\n            print\\(json.dumps\\([]\\), end=''\\)\n            return\n        encode_query\\(args.text\\)\n    elif args.mode == 'server':\n        server_mode\\(\\)\n\n\nif __name__ == '__main__':\n    main\\(\\)\nENDOFFILE)",
      "Bash(grep:*)",
      "Bash(python:*)",
      "Bash(timeout:*)",
      "Bash(python3:*)",
      "Bash(git check-ignore:*)",
      "Bash(certUtil:*)",
      "Bash(npx tsx:*)",
      "Bash(file:*)",
      "Bash(find:*)",
      "Bash(jobs)"
    ]
  }
}
